{"version":3,"sources":["../../../src/lib/payment/base-processor.ts","../../../src/lib/payment/processors/mtn-momo.ts","../../../src/lib/payment/processors/airtel-money.ts","../../../src/lib/payment/processors/equity-bank.ts","../../../src/lib/payment/processors/crypto.ts","../../../src/lib/payment/processors/wallet.ts","../../../src/lib/payment/factory.ts"],"sourcesContent":["import { \n  IPaymentProcessor, \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  PaymentTransaction,\n  PaymentStatus\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\nexport abstract class BasePaymentProcessor implements IPaymentProcessor {\n  protected abstract paymentMethod: string;\n\n  abstract initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse>;\n  abstract verifyPayment(reference: string): Promise<PaymentVerificationResponse>;\n  abstract processWebhook(payload: any): Promise<void>;\n  abstract refundPayment(request: RefundRequest): Promise<RefundResponse>;\n\n  protected async createTransaction(request: PaymentInitRequest, providerReference?: string): Promise<PaymentTransaction> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_transactions')\n      .insert({\n        user_id: request.user_id,\n        listing_id: request.listing_id,\n        ad_campaign_id: request.ad_campaign_id,\n        payment_method: request.payment_method,\n        amount: request.amount,\n        currency: request.currency || 'RWF',\n        transaction_type: request.transaction_type,\n        status: 'pending',\n        provider_reference: providerReference,\n        description: request.description,\n        metadata: request.metadata,\n        expires_at: new Date(Date.now() + 15 * 60 * 1000) // 15 minutes expiry\n      })\n      .select()\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to create payment transaction: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async updateTransactionStatus(\n    reference: string, \n    status: PaymentStatus, \n    providerData?: any\n  ): Promise<PaymentTransaction> {\n    const updateData: any = {\n      status,\n      updated_at: new Date().toISOString()\n    };\n\n    if (status === 'completed') {\n      updateData.completed_at = new Date().toISOString();\n    }\n\n    if (providerData) {\n      updateData.provider_response = providerData;\n    }\n\n    const { data, error } = await supabaseAdmin\n      .from('payment_transactions')\n      .update(updateData)\n      .eq('our_reference', reference)\n      .select()\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to update transaction status: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async getTransaction(reference: string): Promise<PaymentTransaction | null> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_transactions')\n      .select('*')\n      .eq('our_reference', reference)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null; // Not found\n      }\n      throw new Error(`Failed to get transaction: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async logWebhook(paymentMethod: string, eventType: string, payload: any): Promise<void> {\n    await supabaseAdmin\n      .from('payment_webhook_logs')\n      .insert({\n        payment_method: paymentMethod,\n        event_type: eventType,\n        payload,\n        status: 'received'\n      });\n  }\n\n  protected async markWebhookProcessed(logId: string, error?: string): Promise<void> {\n    await supabaseAdmin\n      .from('payment_webhook_logs')\n      .update({\n        processed: true,\n        error_message: error,\n        status: error ? 'failed' : 'success'\n      })\n      .eq('id', logId);\n  }\n\n  protected generateReference(): string {\n    const timestamp = Date.now();\n    const random = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');\n    return `${this.paymentMethod.toUpperCase()}${timestamp}${random}`;\n  }\n\n  protected calculateFees(amount: number, feePercent: number, fixedFee: number): number {\n    return (amount * feePercent / 100) + fixedFee;\n  }\n\n  protected async getPaymentConfig(paymentMethod: string): Promise<any> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_configurations')\n      .select('config_data, is_active')\n      .eq('payment_method', paymentMethod)\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get payment configuration: ${error.message}`);\n    }\n\n    if (!data.is_active) {\n      throw new Error(`Payment method ${paymentMethod} is not active`);\n    }\n\n    return data.config_data;\n  }\n\n  protected async getUserWallet(userId: string): Promise<any> {\n    const { data, error } = await supabaseAdmin\n      .from('user_wallets')\n      .select('*')\n      .eq('user_id', userId)\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get user wallet: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async checkPaymentLimits(\n    paymentMethod: string, \n    amount: number, \n    userTier: string = 'basic'\n  ): Promise<void> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_method_limits')\n      .select('*')\n      .eq('payment_method', paymentMethod)\n      .eq('user_tier', userTier)\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get payment limits: ${error.message}`);\n    }\n\n    if (amount < data.min_amount) {\n      throw new Error(`Minimum amount for ${paymentMethod} is ${data.min_amount} RWF`);\n    }\n\n    if (amount > data.max_amount) {\n      throw new Error(`Maximum amount for ${paymentMethod} is ${data.max_amount} RWF`);\n    }\n\n    // Check daily limit\n    const today = new Date().toISOString().split('T')[0];\n    const { data: todayTransactions } = await supabaseAdmin\n      .from('payment_transactions')\n      .select('amount')\n      .eq('payment_method', paymentMethod)\n      .eq('status', 'completed')\n      .gte('created_at', today);\n\n    const todayTotal = todayTransactions?.reduce((sum: number, tx: any) => sum + Number(tx.amount), 0) || 0;\n    \n    if (todayTotal + amount > data.daily_limit) {\n      throw new Error(`Daily limit exceeded for ${paymentMethod}. Remaining: ${data.daily_limit - todayTotal} RWF`);\n    }\n\n    // Check monthly limit\n    const thisMonth = new Date().toISOString().slice(0, 7);\n    const { data: monthTransactions } = await supabaseAdmin\n      .from('payment_transactions')\n      .select('amount')\n      .eq('payment_method', paymentMethod)\n      .eq('status', 'completed')\n      .gte('created_at', thisMonth);\n\n    const monthTotal = monthTransactions?.reduce((sum: number, tx: any) => sum + Number(tx.amount), 0) || 0;\n    \n    if (monthTotal + amount > data.monthly_limit) {\n      throw new Error(`Monthly limit exceeded for ${paymentMethod}. Remaining: ${data.monthly_limit - monthTotal} RWF`);\n    }\n  }\n}\n","import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  MTNMobileMoneyConfig,\n  PaymentStatus\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\n// Note: Install axios with: npm install axios\n// For now, using fetch API instead\n// import axios from 'axios';\n\nexport class MTNMobileMoneyProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'mtn_momo';\n  private config: MTNMobileMoneyConfig | null = null;\n\n  private async getConfig(): Promise<MTNMobileMoneyConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('mtn_momo');\n    }\n    return this.config;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n      \n      // Validate phone number\n      if (!request.phone_number) {\n        throw new Error('Phone number is required for MTN Mobile Money payments');\n      }\n\n      // Check payment limits\n      await this.checkPaymentLimits('mtn_momo', request.amount);\n\n      // Calculate fees\n      const transactionFee = this.calculateFees(\n        request.amount, \n        config.transaction_fee_percent, \n        config.fixed_fee\n      );\n      const totalAmount = request.amount + transactionFee;\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // Call MTN API\n      const apiEndpoint = config.environment === 'production' \n        ? 'https://api.mtn.com/v1_0' \n        : 'https://sandbox.mtn.com/v1_0';\n\n      const mtnRequest = {\n        amount: totalAmount.toString(),\n        currency: request.currency || 'RWF',\n        externalId: transaction.our_reference,\n        payer: {\n          partyIdType: 'MSISDN',\n          partyId: request.phone_number\n        },\n        payerMessage: request.description || `Payment for ${request.transaction_type}`,\n        payeeNote: `IkazeProperty Payment - ${transaction.our_reference}`\n      };\n\n      const response = await fetch(`${apiEndpoint}/requesttopay`, {\n        method: 'POST',\n        headers: {\n          'Ocp-Apim-Subscription-Key': config.api_key,\n          'X-Reference-Id': transaction.our_reference,\n          'Content-Type': 'application/json',\n          'X-Target-Environment': config.environment\n        },\n        body: JSON.stringify(mtnRequest)\n      });\n\n      const responseData = await response.json();\n\n      // Update transaction with provider reference\n      await this.updateTransactionStatus(\n        transaction.our_reference, \n        'pending', \n        responseData\n      );\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        provider_reference: responseData.transactionId || transaction.our_reference,\n        instructions: 'Please check your phone for the MTN Mobile Money payment prompt',\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate MTN Mobile Money payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const config = await this.getConfig();\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // If already completed, return current status\n      if (transaction.status === 'completed') {\n        return {\n          success: true,\n          status: 'completed',\n          data: transaction.provider_response\n        };\n      }\n\n      // Check if expired\n      if (transaction.expires_at && new Date() > new Date(transaction.expires_at)) {\n        await this.updateTransactionStatus(reference, 'expired');\n        return {\n          success: false,\n          status: 'expired',\n          error: 'Transaction has expired'\n        };\n      }\n\n      // Poll MTN API for status\n      const apiEndpoint = config.environment === 'production' \n        ? 'https://api.mtn.com/v1_0' \n        : 'https://sandbox.mtn.com/v1_0';\n\n      const response = await fetch(`${apiEndpoint}/requesttopay/${reference}`, {\n        headers: {\n          'Ocp-Apim-Subscription-Key': config.api_key,\n          'X-Target-Environment': config.environment\n        }\n      });\n\n      const responseData = await response.json();\n      const status = responseData.status;\n\n      if (status === 'SUCCESSFUL') {\n        await this.updateTransactionStatus(reference, 'completed', responseData);\n        return {\n          success: true,\n          status: 'completed',\n          data: responseData\n        };\n      } else if (status === 'FAILED') {\n        await this.updateTransactionStatus(reference, 'failed', responseData);\n        return {\n          success: false,\n          status: 'failed',\n          data: responseData\n        };\n      } else {\n        // Still pending\n        return {\n          success: false,\n          status: 'pending',\n          data: responseData\n        };\n      }\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('mtn_momo', 'payment_callback', payload);\n\n      const reference = payload.externalId;\n      const status = payload.status;\n\n      if (!reference) {\n        throw new Error('Missing externalId in webhook payload');\n      }\n\n      let paymentStatus: PaymentStatus;\n\n      switch (status) {\n        case 'SUCCESSFUL':\n          paymentStatus = 'completed';\n          break;\n        case 'FAILED':\n          paymentStatus = 'failed';\n          break;\n        case 'EXPIRED':\n          paymentStatus = 'expired';\n          break;\n        default:\n          paymentStatus = 'pending';\n      }\n\n      await this.updateTransactionStatus(reference, paymentStatus, payload);\n\n      // If payment is successful, you might want to trigger additional actions\n      if (paymentStatus === 'completed') {\n        const transaction = await this.getTransaction(reference);\n        if (transaction) {\n          // Activate promotion, send confirmation, etc.\n          await this.handleSuccessfulPayment(transaction);\n        }\n      }\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      const config = await this.getConfig();\n      const originalTransaction = await this.getTransaction(request.original_transaction_id);\n\n      if (!originalTransaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Original transaction not found'\n        };\n      }\n\n      if (originalTransaction.status !== 'completed') {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Cannot refund a non-completed transaction'\n        };\n      }\n\n      // Call MTN refund API\n      const apiEndpoint = config.environment === 'production' \n        ? 'https://api.mtn.com/v1_0' \n        : 'https://sandbox.mtn.com/v1_0';\n\n      const refundRequest = {\n        amount: request.amount || originalTransaction.amount,\n        currency: originalTransaction.currency,\n        externalId: `REFUND_${this.generateReference()}`,\n        payerMessage: `Refund for transaction ${originalTransaction.our_reference}`,\n        payeeNote: request.reason\n      };\n\n      const response = await fetch(`${apiEndpoint}/refund`, {\n        method: 'POST',\n        headers: {\n          'Ocp-Apim-Subscription-Key': config.api_key,\n          'X-Reference-Id': refundRequest.externalId,\n          'Content-Type': 'application/json',\n          'X-Target-Environment': config.environment\n        },\n        body: JSON.stringify(refundRequest)\n      });\n\n      const responseData = await response.json();\n\n      // Create refund record\n      const { data: refundRecord } = await supabaseAdmin\n        .from('payment_refunds')\n        .insert({\n          original_transaction_id: request.original_transaction_id,\n          amount: request.amount || originalTransaction.amount,\n          reason: request.reason,\n          status: 'pending',\n          processed_by: request.processed_by\n        })\n        .select()\n        .single();\n\n      return {\n        success: true,\n        refund_transaction_id: refundRecord.id,\n        status: 'pending'\n      };\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process refund'\n      };\n    }\n  }\n\n  private async handleSuccessfulPayment(transaction: any): Promise<void> {\n    // This method can be extended to handle post-payment actions\n    // such as activating promotions, sending notifications, etc.\n    console.log('Payment successful:', transaction.our_reference);\n    \n    // Example: Activate promotion if this was a promotion payment\n    if (transaction.transaction_type === 'ad_promotion' && transaction.listing_id) {\n      // Implementation would go here\n    }\n  }\n}\n","import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  AirtelMoneyConfig\n} from '@/types/payment';\n\nexport class AirtelMoneyProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'airtel_money';\n  private config: AirtelMoneyConfig | null = null;\n\n  private async getConfig(): Promise<AirtelMoneyConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('airtel_money');\n    }\n    return this.config;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n      \n      // Validate phone number\n      if (!request.phone_number) {\n        throw new Error('Phone number is required for Airtel Money payments');\n      }\n\n      // Check payment limits\n      await this.checkPaymentLimits('airtel_money', request.amount);\n\n      // Calculate fees\n      const transactionFee = this.calculateFees(\n        request.amount, \n        config.transaction_fee_percent, \n        config.fixed_fee\n      );\n      const totalAmount = request.amount + transactionFee;\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // TODO: Implement Airtel Money API integration\n      // For now, return a mock response\n      console.log('Airtel Money payment initiated:', {\n        reference,\n        amount: totalAmount,\n        phone: request.phone_number\n      });\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        provider_reference: reference,\n        instructions: 'Please check your phone for the Airtel Money payment prompt',\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('Airtel Money payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate Airtel Money payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // TODO: Implement Airtel Money verification\n      // For now, return pending status\n      return {\n        success: false,\n        status: 'pending',\n        data: { message: 'Airtel Money verification not yet implemented' }\n      };\n\n    } catch (error: any) {\n      console.error('Airtel Money payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('airtel_money', 'payment_callback', payload);\n\n      // TODO: Implement Airtel Money webhook processing\n      console.log('Airtel Money webhook received:', payload);\n\n    } catch (error: any) {\n      console.error('Airtel Money webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      // TODO: Implement Airtel Money refund\n      console.log('Airtel Money refund requested:', request);\n\n      return {\n        success: false,\n        status: 'failed',\n        error: 'Airtel Money refunds not yet implemented'\n      };\n\n    } catch (error: any) {\n      console.error('Airtel Money refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process refund'\n      };\n    }\n  }\n}\n","import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  EquityBankConfig\n} from '@/types/payment';\n\nexport class EquityBankProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'equity_bank';\n  private config: EquityBankConfig | null = null;\n\n  private async getConfig(): Promise<EquityBankConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('equity_bank');\n    }\n    return this.config;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n\n      // Check payment limits\n      await this.checkPaymentLimits('equity_bank', request.amount);\n\n      // Calculate fees\n      const transactionFee = this.calculateFees(\n        request.amount, \n        config.transaction_fee_percent, \n        config.fixed_fee\n      );\n      const totalAmount = request.amount + transactionFee;\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // TODO: Implement Equity Bank API integration\n      // For now, return bank transfer instructions\n      console.log('Equity Bank payment initiated:', {\n        reference,\n        amount: totalAmount,\n        account: config.account_number\n      });\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        provider_reference: reference,\n        instructions: `Please transfer ${totalAmount} RWF to Equity Bank account ${config.account_number} (${config.account_name}). Reference: ${transaction.our_reference}`,\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('Equity Bank payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate Equity Bank payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // TODO: Implement Equity Bank verification\n      // For now, return pending status\n      return {\n        success: false,\n        status: 'pending',\n        data: { message: 'Equity Bank verification not yet implemented' }\n      };\n\n    } catch (error: any) {\n      console.error('Equity Bank payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('equity_bank', 'payment_callback', payload);\n\n      // TODO: Implement Equity Bank webhook processing\n      console.log('Equity Bank webhook received:', payload);\n\n    } catch (error: any) {\n      console.error('Equity Bank webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      // TODO: Implement Equity Bank refund\n      console.log('Equity Bank refund requested:', request);\n\n      return {\n        success: false,\n        status: 'failed',\n        error: 'Equity Bank refunds not yet implemented'\n      };\n\n    } catch (error: any) {\n      console.error('Equity Bank refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process refund'\n      };\n    }\n  }\n}\n","import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  CryptoConfig,\n  CryptoType\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\nexport class CryptoPaymentProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'crypto';\n  private config: CryptoConfig | null = null;\n\n  private async getConfig(): Promise<CryptoConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('crypto');\n    }\n    return this.config;\n  }\n\n  private async getExchangeRate(fromCurrency: string, toCurrency: string): Promise<number> {\n    const { data, error } = await supabaseAdmin\n      .from('exchange_rates')\n      .select('rate')\n      .eq('from_currency', fromCurrency)\n      .eq('to_currency', toCurrency)\n      .eq('source', 'coinbase')\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get exchange rate: ${error.message}`);\n    }\n\n    return data.rate;\n  }\n\n  private async convertToCrypto(amountRWF: number, cryptoType: CryptoType): Promise<number> {\n    const config = await this.getConfig();\n    \n    if (config.exchange_rate_provider === 'manual' && config.manual_exchange_rate) {\n      // Convert RWF to USD first, then to crypto\n      const usdAmount = amountRWF / config.manual_exchange_rate;\n      \n      switch (cryptoType) {\n        case 'bitcoin':\n          return usdAmount / 45000; // Approximate BTC price\n        case 'ethereum':\n          return usdAmount / 2500; // Approximate ETH price\n        case 'usdt':\n          return usdAmount; // USDT is pegged to USD\n        default:\n          throw new Error(`Unsupported crypto type: ${cryptoType}`);\n      }\n    } else {\n      // Get real exchange rates\n      const usdRate = await this.getExchangeRate('USD', 'RWF');\n      const usdAmount = amountRWF / usdRate;\n      \n      const cryptoRate = await this.getExchangeRate(cryptoType.toUpperCase(), 'USD');\n      return usdAmount / cryptoRate;\n    }\n  }\n\n  private getCryptoWalletAddress(cryptoType: CryptoType): string {\n    if (!this.config) {\n      throw new Error('Crypto configuration not loaded');\n    }\n\n    switch (cryptoType) {\n      case 'bitcoin':\n        return this.config.bitcoin.wallet_address;\n      case 'ethereum':\n        return this.config.ethereum.wallet_address;\n      case 'usdt':\n        return this.config.usdt.wallet_address;\n      default:\n        throw new Error(`Unsupported crypto type: ${cryptoType}`);\n    }\n  }\n\n  private generateQRCode(address: string, amount?: number): string {\n    // Simple QR code generation - in production, use a proper QR code library\n    const qrData = amount ? `${address}?amount=${amount}` : address;\n    const svg = `<svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"200\" height=\"200\" fill=\"white\"/>\n      <text x=\"100\" y=\"100\" text-anchor=\"middle\" font-size=\"12\">QR Code</text>\n      <text x=\"100\" y=\"120\" text-anchor=\"middle\" font-size=\"8\">${address.substring(0, 20)}...</text>\n    </svg>`;\n    return `data:image/svg+xml;base64,${Buffer.from(svg).toString('base64')}`;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n\n      if (!request.crypto_type) {\n        throw new Error('Crypto type is required for crypto payments');\n      }\n\n      if (!config[request.crypto_type].enabled) {\n        throw new Error(`${request.crypto_type} payments are not enabled`);\n      }\n\n      // Check payment limits\n      await this.checkPaymentLimits('crypto', request.amount);\n\n      // Convert RWF amount to crypto\n      const cryptoAmount = await this.convertToCrypto(request.amount, request.crypto_type);\n      const walletAddress = this.getCryptoWalletAddress(request.crypto_type);\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // Generate QR code\n      const qrCodeUrl = this.generateQRCode(walletAddress, cryptoAmount);\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        wallet_address: walletAddress,\n        amount: cryptoAmount,\n        currency: request.crypto_type.toUpperCase(),\n        qr_code_url: qrCodeUrl,\n        exchange_rate: await this.getExchangeRate(request.crypto_type.toUpperCase(), 'RWF'),\n        instructions: `Please send ${cryptoAmount} ${request.crypto_type.toUpperCase()} to the provided address`,\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('Crypto payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate crypto payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // Check if expired\n      if (transaction.expires_at && new Date() > new Date(transaction.expires_at)) {\n        await this.updateTransactionStatus(reference, 'expired');\n        return {\n          success: false,\n          status: 'expired',\n          error: 'Transaction has expired'\n        };\n      }\n\n      // TODO: Implement blockchain monitoring\n      // For now, return pending status\n      return {\n        success: false,\n        status: 'pending',\n        data: { message: 'Crypto payment verification not yet implemented' }\n      };\n\n    } catch (error: any) {\n      console.error('Crypto payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify crypto payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('crypto', 'payment_callback', payload);\n\n      // TODO: Implement crypto webhook processing\n      console.log('Crypto webhook received:', payload);\n\n    } catch (error: any) {\n      console.error('Crypto webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      // TODO: Implement crypto refund\n      console.log('Crypto refund requested:', request);\n\n      return {\n        success: false,\n        status: 'failed',\n        error: 'Crypto refunds not yet implemented'\n      };\n\n    } catch (error: any) {\n      console.error('Crypto refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process crypto refund'\n      };\n    }\n  }\n}\n","import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  PaymentStatus\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\nexport class WalletPaymentProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'wallet';\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      // Get user wallet\n      const wallet = await this.getUserWallet(request.user_id);\n\n      // Check if user has sufficient balance\n      if (wallet.balance < request.amount) {\n        return {\n          success: false,\n          reference: '',\n          error: `Insufficient wallet balance. Available: ${wallet.balance} RWF, Required: ${request.amount} RWF`\n        };\n      }\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request);\n\n      // Process wallet payment immediately\n      await this.updateTransactionStatus(transaction.our_reference, 'completed');\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        instructions: 'Payment completed successfully using wallet balance'\n      };\n\n    } catch (error: any) {\n      console.error('Wallet payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to process wallet payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      return {\n        success: true,\n        status: transaction.status,\n        data: transaction\n      };\n\n    } catch (error: any) {\n      console.error('Wallet payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify wallet payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    // Wallet payments don't typically use webhooks since they're processed synchronously\n    console.log('Wallet webhook received (unexpected):', payload);\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      const originalTransaction = await this.getTransaction(request.original_transaction_id);\n\n      if (!originalTransaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Original transaction not found'\n        };\n      }\n\n      if (originalTransaction.status !== 'completed') {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Cannot refund a non-completed transaction'\n        };\n      }\n\n      // Create refund transaction\n      const refundTransaction = await this.createTransaction({\n        user_id: originalTransaction.user_id,\n        payment_method: 'wallet',\n        amount: request.amount || originalTransaction.amount,\n        currency: originalTransaction.currency,\n        transaction_type: 'refund',\n        description: `Refund for transaction ${originalTransaction.our_reference}: ${request.reason}`,\n        metadata: {\n          original_transaction_id: originalTransaction.id,\n          refund_reason: request.reason\n        }\n      });\n\n      // Process refund immediately\n      await this.updateTransactionStatus(refundTransaction.our_reference, 'completed');\n\n      // Create refund record\n      const { data: refundRecord } = await supabaseAdmin\n        .from('payment_refunds')\n        .insert({\n          original_transaction_id: request.original_transaction_id,\n          refund_transaction_id: refundTransaction.id,\n          amount: request.amount || originalTransaction.amount,\n          reason: request.reason,\n          status: 'completed',\n          processed_by: request.processed_by,\n          processed_at: new Date().toISOString()\n        })\n        .select()\n        .single();\n\n      return {\n        success: true,\n        refund_transaction_id: refundRecord.id,\n        status: 'completed'\n      };\n\n    } catch (error: any) {\n      console.error('Wallet refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process wallet refund'\n      };\n    }\n  }\n}\n","import { \n  PaymentMethod, \n  IPaymentProcessor, \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse\n} from '@/types/payment';\nimport { MTNMobileMoneyProcessor } from './processors/mtn-momo';\nimport { AirtelMoneyProcessor } from './processors/airtel-money';\nimport { EquityBankProcessor } from './processors/equity-bank';\nimport { CryptoPaymentProcessor } from './processors/crypto';\nimport { WalletPaymentProcessor } from './processors/wallet';\n\nexport class PaymentProcessorFactory {\n  private static processors: Map<PaymentMethod, IPaymentProcessor> = new Map();\n\n  static createProcessor(method: PaymentMethod): IPaymentProcessor {\n    // Check if we already have an instance\n    if (this.processors.has(method)) {\n      return this.processors.get(method)!;\n    }\n\n    let processor: IPaymentProcessor;\n\n    switch (method) {\n      case 'mtn_momo':\n        processor = new MTNMobileMoneyProcessor();\n        break;\n      case 'airtel_money':\n        processor = new AirtelMoneyProcessor();\n        break;\n      case 'equity_bank':\n        processor = new EquityBankProcessor();\n        break;\n      case 'crypto':\n        processor = new CryptoPaymentProcessor();\n        break;\n      case 'wallet':\n        processor = new WalletPaymentProcessor();\n        break;\n      default:\n        throw new Error(`Unsupported payment method: ${method}`);\n    }\n\n    // Cache the processor instance\n    this.processors.set(method, processor);\n    return processor;\n  }\n\n  static async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    const processor = this.createProcessor(request.payment_method);\n    return await processor.initiatePayment(request);\n  }\n\n  static async verifyPayment(method: PaymentMethod, reference: string): Promise<PaymentVerificationResponse> {\n    const processor = this.createProcessor(method);\n    return await processor.verifyPayment(reference);\n  }\n\n  static async processWebhook(method: PaymentMethod, payload: any): Promise<void> {\n    const processor = this.createProcessor(method);\n    return await processor.processWebhook(payload);\n  }\n\n  static async refundPayment(method: PaymentMethod, request: RefundRequest): Promise<RefundResponse> {\n    const processor = this.createProcessor(method);\n    return await processor.refundPayment(request);\n  }\n\n  static getSupportedMethods(): PaymentMethod[] {\n    return ['mtn_momo', 'airtel_money', 'equity_bank', 'crypto', 'wallet'];\n  }\n\n  static async isMethodAvailable(method: PaymentMethod): Promise<boolean> {\n    try {\n      const processor = this.createProcessor(method);\n      // You could add a health check method to each processor\n      return true;\n    } catch (error) {\n      console.error(`Payment method ${method} not available:`, error);\n      return false;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}