{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\n\n// Environment variables with fallbacks for development\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://swshkufpktnacbotddpb.supabase.co';\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN3c2hrdWZwa3RuYWNib3RkZHBiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0NTE4MzksImV4cCI6MjA4NjAyNzgzOX0.XjlJZscCno-_czhwXqwdSlKgUUpDZty6i37mtwqcnA8';\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN3c2hrdWZwa3RuYWNib3RkZHBiIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc3MDQ1MTgzOSwiZXhwIjoyMDg2MDI3ODM5fQ.T_LnaxClQV-ddubCnBnVk0d0lgkmT0GUs1EsD1qVG3U';\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// For server-side operations\nexport const supabaseAdmin = createClient(\n  supabaseUrl,\n  supabaseServiceRoleKey\n);\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,uDAAuD;AACvD,MAAM,cAAc,gFAAwC;AAC5D,MAAM,kBAAkB,wPAA6C;AACrE,MAAM,yBAAyB,QAAQ,GAAG,CAAC,yBAAyB,IAAI;AAEjE,MAAM,WAAW,IAAA,gMAAY,EAAC,aAAa;AAG3C,MAAM,gBAAgB,IAAA,gMAAY,EACvC,aACA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/payment/base-processor.ts"],"sourcesContent":["import { \n  IPaymentProcessor, \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  PaymentTransaction,\n  PaymentStatus\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\nexport abstract class BasePaymentProcessor implements IPaymentProcessor {\n  protected abstract paymentMethod: string;\n\n  abstract initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse>;\n  abstract verifyPayment(reference: string): Promise<PaymentVerificationResponse>;\n  abstract processWebhook(payload: any): Promise<void>;\n  abstract refundPayment(request: RefundRequest): Promise<RefundResponse>;\n\n  protected async createTransaction(request: PaymentInitRequest, providerReference?: string): Promise<PaymentTransaction> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_transactions')\n      .insert({\n        user_id: request.user_id,\n        listing_id: request.listing_id,\n        ad_campaign_id: request.ad_campaign_id,\n        payment_method: request.payment_method,\n        amount: request.amount,\n        currency: request.currency || 'RWF',\n        transaction_type: request.transaction_type,\n        status: 'pending',\n        provider_reference: providerReference,\n        description: request.description,\n        metadata: request.metadata,\n        expires_at: new Date(Date.now() + 15 * 60 * 1000) // 15 minutes expiry\n      })\n      .select()\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to create payment transaction: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async updateTransactionStatus(\n    reference: string, \n    status: PaymentStatus, \n    providerData?: any\n  ): Promise<PaymentTransaction> {\n    const updateData: any = {\n      status,\n      updated_at: new Date().toISOString()\n    };\n\n    if (status === 'completed') {\n      updateData.completed_at = new Date().toISOString();\n    }\n\n    if (providerData) {\n      updateData.provider_response = providerData;\n    }\n\n    const { data, error } = await supabaseAdmin\n      .from('payment_transactions')\n      .update(updateData)\n      .eq('our_reference', reference)\n      .select()\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to update transaction status: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async getTransaction(reference: string): Promise<PaymentTransaction | null> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_transactions')\n      .select('*')\n      .eq('our_reference', reference)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null; // Not found\n      }\n      throw new Error(`Failed to get transaction: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async logWebhook(paymentMethod: string, eventType: string, payload: any): Promise<void> {\n    await supabaseAdmin\n      .from('payment_webhook_logs')\n      .insert({\n        payment_method: paymentMethod,\n        event_type: eventType,\n        payload,\n        status: 'received'\n      });\n  }\n\n  protected async markWebhookProcessed(logId: string, error?: string): Promise<void> {\n    await supabaseAdmin\n      .from('payment_webhook_logs')\n      .update({\n        processed: true,\n        error_message: error,\n        status: error ? 'failed' : 'success'\n      })\n      .eq('id', logId);\n  }\n\n  protected generateReference(): string {\n    const timestamp = Date.now();\n    const random = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');\n    return `${this.paymentMethod.toUpperCase()}${timestamp}${random}`;\n  }\n\n  protected calculateFees(amount: number, feePercent: number, fixedFee: number): number {\n    return (amount * feePercent / 100) + fixedFee;\n  }\n\n  protected async getPaymentConfig(paymentMethod: string): Promise<any> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_configurations')\n      .select('config_data, is_active')\n      .eq('payment_method', paymentMethod)\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get payment configuration: ${error.message}`);\n    }\n\n    if (!data.is_active) {\n      throw new Error(`Payment method ${paymentMethod} is not active`);\n    }\n\n    return data.config_data;\n  }\n\n  protected async getUserWallet(userId: string): Promise<any> {\n    const { data, error } = await supabaseAdmin\n      .from('user_wallets')\n      .select('*')\n      .eq('user_id', userId)\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get user wallet: ${error.message}`);\n    }\n\n    return data;\n  }\n\n  protected async checkPaymentLimits(\n    paymentMethod: string, \n    amount: number, \n    userTier: string = 'basic'\n  ): Promise<void> {\n    const { data, error } = await supabaseAdmin\n      .from('payment_method_limits')\n      .select('*')\n      .eq('payment_method', paymentMethod)\n      .eq('user_tier', userTier)\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get payment limits: ${error.message}`);\n    }\n\n    if (amount < data.min_amount) {\n      throw new Error(`Minimum amount for ${paymentMethod} is ${data.min_amount} RWF`);\n    }\n\n    if (amount > data.max_amount) {\n      throw new Error(`Maximum amount for ${paymentMethod} is ${data.max_amount} RWF`);\n    }\n\n    // Check daily limit\n    const today = new Date().toISOString().split('T')[0];\n    const { data: todayTransactions } = await supabaseAdmin\n      .from('payment_transactions')\n      .select('amount')\n      .eq('payment_method', paymentMethod)\n      .eq('status', 'completed')\n      .gte('created_at', today);\n\n    const todayTotal = todayTransactions?.reduce((sum: number, tx: any) => sum + Number(tx.amount), 0) || 0;\n    \n    if (todayTotal + amount > data.daily_limit) {\n      throw new Error(`Daily limit exceeded for ${paymentMethod}. Remaining: ${data.daily_limit - todayTotal} RWF`);\n    }\n\n    // Check monthly limit\n    const thisMonth = new Date().toISOString().slice(0, 7);\n    const { data: monthTransactions } = await supabaseAdmin\n      .from('payment_transactions')\n      .select('amount')\n      .eq('payment_method', paymentMethod)\n      .eq('status', 'completed')\n      .gte('created_at', thisMonth);\n\n    const monthTotal = monthTransactions?.reduce((sum: number, tx: any) => sum + Number(tx.amount), 0) || 0;\n    \n    if (monthTotal + amount > data.monthly_limit) {\n      throw new Error(`Monthly limit exceeded for ${paymentMethod}. Remaining: ${data.monthly_limit - monthTotal} RWF`);\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/payment/processors/mtn-momo.ts"],"sourcesContent":["import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  MTNMobileMoneyConfig,\n  PaymentStatus\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\n// Note: Install axios with: npm install axios\n// For now, using fetch API instead\n// import axios from 'axios';\n\nexport class MTNMobileMoneyProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'mtn_momo';\n  private config: MTNMobileMoneyConfig | null = null;\n\n  private async getConfig(): Promise<MTNMobileMoneyConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('mtn_momo');\n    }\n    return this.config;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n      \n      // Validate phone number\n      if (!request.phone_number) {\n        throw new Error('Phone number is required for MTN Mobile Money payments');\n      }\n\n      // Check payment limits\n      await this.checkPaymentLimits('mtn_momo', request.amount);\n\n      // Calculate fees\n      const transactionFee = this.calculateFees(\n        request.amount, \n        config.transaction_fee_percent, \n        config.fixed_fee\n      );\n      const totalAmount = request.amount + transactionFee;\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // Call MTN API\n      const apiEndpoint = config.environment === 'production' \n        ? 'https://api.mtn.com/v1_0' \n        : 'https://sandbox.mtn.com/v1_0';\n\n      const mtnRequest = {\n        amount: totalAmount.toString(),\n        currency: request.currency || 'RWF',\n        externalId: transaction.our_reference,\n        payer: {\n          partyIdType: 'MSISDN',\n          partyId: request.phone_number\n        },\n        payerMessage: request.description || `Payment for ${request.transaction_type}`,\n        payeeNote: `IkazeProperty Payment - ${transaction.our_reference}`\n      };\n\n      const response = await fetch(`${apiEndpoint}/requesttopay`, {\n        method: 'POST',\n        headers: {\n          'Ocp-Apim-Subscription-Key': config.api_key,\n          'X-Reference-Id': transaction.our_reference,\n          'Content-Type': 'application/json',\n          'X-Target-Environment': config.environment\n        },\n        body: JSON.stringify(mtnRequest)\n      });\n\n      const responseData = await response.json();\n\n      // Update transaction with provider reference\n      await this.updateTransactionStatus(\n        transaction.our_reference, \n        'pending', \n        responseData\n      );\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        provider_reference: responseData.transactionId || transaction.our_reference,\n        instructions: 'Please check your phone for the MTN Mobile Money payment prompt',\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate MTN Mobile Money payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const config = await this.getConfig();\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // If already completed, return current status\n      if (transaction.status === 'completed') {\n        return {\n          success: true,\n          status: 'completed',\n          data: transaction.provider_response\n        };\n      }\n\n      // Check if expired\n      if (transaction.expires_at && new Date() > new Date(transaction.expires_at)) {\n        await this.updateTransactionStatus(reference, 'expired');\n        return {\n          success: false,\n          status: 'expired',\n          error: 'Transaction has expired'\n        };\n      }\n\n      // Poll MTN API for status\n      const apiEndpoint = config.environment === 'production' \n        ? 'https://api.mtn.com/v1_0' \n        : 'https://sandbox.mtn.com/v1_0';\n\n      const response = await fetch(`${apiEndpoint}/requesttopay/${reference}`, {\n        headers: {\n          'Ocp-Apim-Subscription-Key': config.api_key,\n          'X-Target-Environment': config.environment\n        }\n      });\n\n      const responseData = await response.json();\n      const status = responseData.status;\n\n      if (status === 'SUCCESSFUL') {\n        await this.updateTransactionStatus(reference, 'completed', responseData);\n        return {\n          success: true,\n          status: 'completed',\n          data: responseData\n        };\n      } else if (status === 'FAILED') {\n        await this.updateTransactionStatus(reference, 'failed', responseData);\n        return {\n          success: false,\n          status: 'failed',\n          data: responseData\n        };\n      } else {\n        // Still pending\n        return {\n          success: false,\n          status: 'pending',\n          data: responseData\n        };\n      }\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('mtn_momo', 'payment_callback', payload);\n\n      const reference = payload.externalId;\n      const status = payload.status;\n\n      if (!reference) {\n        throw new Error('Missing externalId in webhook payload');\n      }\n\n      let paymentStatus: PaymentStatus;\n\n      switch (status) {\n        case 'SUCCESSFUL':\n          paymentStatus = 'completed';\n          break;\n        case 'FAILED':\n          paymentStatus = 'failed';\n          break;\n        case 'EXPIRED':\n          paymentStatus = 'expired';\n          break;\n        default:\n          paymentStatus = 'pending';\n      }\n\n      await this.updateTransactionStatus(reference, paymentStatus, payload);\n\n      // If payment is successful, you might want to trigger additional actions\n      if (paymentStatus === 'completed') {\n        const transaction = await this.getTransaction(reference);\n        if (transaction) {\n          // Activate promotion, send confirmation, etc.\n          await this.handleSuccessfulPayment(transaction);\n        }\n      }\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      const config = await this.getConfig();\n      const originalTransaction = await this.getTransaction(request.original_transaction_id);\n\n      if (!originalTransaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Original transaction not found'\n        };\n      }\n\n      if (originalTransaction.status !== 'completed') {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Cannot refund a non-completed transaction'\n        };\n      }\n\n      // Call MTN refund API\n      const apiEndpoint = config.environment === 'production' \n        ? 'https://api.mtn.com/v1_0' \n        : 'https://sandbox.mtn.com/v1_0';\n\n      const refundRequest = {\n        amount: request.amount || originalTransaction.amount,\n        currency: originalTransaction.currency,\n        externalId: `REFUND_${this.generateReference()}`,\n        payerMessage: `Refund for transaction ${originalTransaction.our_reference}`,\n        payeeNote: request.reason\n      };\n\n      const response = await fetch(`${apiEndpoint}/refund`, {\n        method: 'POST',\n        headers: {\n          'Ocp-Apim-Subscription-Key': config.api_key,\n          'X-Reference-Id': refundRequest.externalId,\n          'Content-Type': 'application/json',\n          'X-Target-Environment': config.environment\n        },\n        body: JSON.stringify(refundRequest)\n      });\n\n      const responseData = await response.json();\n\n      // Create refund record\n      const { data: refundRecord } = await supabaseAdmin\n        .from('payment_refunds')\n        .insert({\n          original_transaction_id: request.original_transaction_id,\n          amount: request.amount || originalTransaction.amount,\n          reason: request.reason,\n          status: 'pending',\n          processed_by: request.processed_by\n        })\n        .select()\n        .single();\n\n      return {\n        success: true,\n        refund_transaction_id: refundRecord.id,\n        status: 'pending'\n      };\n\n    } catch (error: any) {\n      console.error('MTN Mobile Money refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process refund'\n      };\n    }\n  }\n\n  private async handleSuccessfulPayment(transaction: any): Promise<void> {\n    // This method can be extended to handle post-payment actions\n    // such as activating promotions, sending notifications, etc.\n    console.log('Payment successful:', transaction.our_reference);\n    \n    // Example: Activate promotion if this was a promotion payment\n    if (transaction.transaction_type === 'ad_promotion' && transaction.listing_id) {\n      // Implementation would go here\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/payment/processors/airtel-money.ts"],"sourcesContent":["import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  AirtelMoneyConfig\n} from '@/types/payment';\n\nexport class AirtelMoneyProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'airtel_money';\n  private config: AirtelMoneyConfig | null = null;\n\n  private async getConfig(): Promise<AirtelMoneyConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('airtel_money');\n    }\n    return this.config;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n      \n      // Validate phone number\n      if (!request.phone_number) {\n        throw new Error('Phone number is required for Airtel Money payments');\n      }\n\n      // Check payment limits\n      await this.checkPaymentLimits('airtel_money', request.amount);\n\n      // Calculate fees\n      const transactionFee = this.calculateFees(\n        request.amount, \n        config.transaction_fee_percent, \n        config.fixed_fee\n      );\n      const totalAmount = request.amount + transactionFee;\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // TODO: Implement Airtel Money API integration\n      // For now, return a mock response\n      console.log('Airtel Money payment initiated:', {\n        reference,\n        amount: totalAmount,\n        phone: request.phone_number\n      });\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        provider_reference: reference,\n        instructions: 'Please check your phone for the Airtel Money payment prompt',\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('Airtel Money payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate Airtel Money payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // TODO: Implement Airtel Money verification\n      // For now, return pending status\n      return {\n        success: false,\n        status: 'pending',\n        data: { message: 'Airtel Money verification not yet implemented' }\n      };\n\n    } catch (error: any) {\n      console.error('Airtel Money payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('airtel_money', 'payment_callback', payload);\n\n      // TODO: Implement Airtel Money webhook processing\n      console.log('Airtel Money webhook received:', payload);\n\n    } catch (error: any) {\n      console.error('Airtel Money webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      // TODO: Implement Airtel Money refund\n      console.log('Airtel Money refund requested:', request);\n\n      return {\n        success: false,\n        status: 'failed',\n        error: 'Airtel Money refunds not yet implemented'\n      };\n\n    } catch (error: any) {\n      console.error('Airtel Money refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process refund'\n      };\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAUO,MAAM,6BAA6B,oKAAoB;IAClD,gBAAgB,eAAe;IACjC,SAAmC,KAAK;IAEhD,MAAc,YAAwC;QACpD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAChB,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC;QAC5C;QACA,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA,MAAM,gBAAgB,OAA2B,EAAgC;QAC/E,IAAI;YACF,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;YAEnC,wBAAwB;YACxB,IAAI,CAAC,QAAQ,YAAY,EAAE;gBACzB,MAAM,IAAI,MAAM;YAClB;YAEA,uBAAuB;YACvB,MAAM,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,QAAQ,MAAM;YAE5D,iBAAiB;YACjB,MAAM,iBAAiB,IAAI,CAAC,aAAa,CACvC,QAAQ,MAAM,EACd,OAAO,uBAAuB,EAC9B,OAAO,SAAS;YAElB,MAAM,cAAc,QAAQ,MAAM,GAAG;YAErC,qBAAqB;YACrB,MAAM,YAAY,IAAI,CAAC,iBAAiB;YAExC,4BAA4B;YAC5B,MAAM,cAAc,MAAM,IAAI,CAAC,iBAAiB,CAAC,SAAS;YAE1D,+CAA+C;YAC/C,kCAAkC;YAClC,QAAQ,GAAG,CAAC,mCAAmC;gBAC7C;gBACA,QAAQ;gBACR,OAAO,QAAQ,YAAY;YAC7B;YAEA,OAAO;gBACL,SAAS;gBACT,WAAW,YAAY,aAAa;gBACpC,oBAAoB;gBACpB,cAAc;gBACd,YAAY,YAAY,UAAU;YACpC;QAEF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,2CAA2C;YACzD,OAAO;gBACL,SAAS;gBACT,WAAW;gBACX,OAAO,MAAM,OAAO,IAAI;YAC1B;QACF;IACF;IAEA,MAAM,cAAc,SAAiB,EAAwC;QAC3E,IAAI;YACF,MAAM,cAAc,MAAM,IAAI,CAAC,cAAc,CAAC;YAE9C,IAAI,CAAC,aAAa;gBAChB,OAAO;oBACL,SAAS;oBACT,QAAQ;oBACR,OAAO;gBACT;YACF;YAEA,4CAA4C;YAC5C,iCAAiC;YACjC,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,MAAM;oBAAE,SAAS;gBAAgD;YACnE;QAEF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,6CAA6C;YAC3D,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,OAAO,MAAM,OAAO,IAAI;YAC1B;QACF;IACF;IAEA,MAAM,eAAe,OAAY,EAAiB;QAChD,IAAI;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,gBAAgB,oBAAoB;YAE1D,kDAAkD;YAClD,QAAQ,GAAG,CAAC,kCAAkC;QAEhD,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,2CAA2C;YACzD,MAAM;QACR;IACF;IAEA,MAAM,cAAc,OAAsB,EAA2B;QACnE,IAAI;YACF,sCAAsC;YACtC,QAAQ,GAAG,CAAC,kCAAkC;YAE9C,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,OAAO;YACT;QAEF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,OAAO,MAAM,OAAO,IAAI;YAC1B;QACF;IACF;AACF"}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/payment/processors/equity-bank.ts"],"sourcesContent":["import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  EquityBankConfig\n} from '@/types/payment';\n\nexport class EquityBankProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'equity_bank';\n  private config: EquityBankConfig | null = null;\n\n  private async getConfig(): Promise<EquityBankConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('equity_bank');\n    }\n    return this.config;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n\n      // Check payment limits\n      await this.checkPaymentLimits('equity_bank', request.amount);\n\n      // Calculate fees\n      const transactionFee = this.calculateFees(\n        request.amount, \n        config.transaction_fee_percent, \n        config.fixed_fee\n      );\n      const totalAmount = request.amount + transactionFee;\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // TODO: Implement Equity Bank API integration\n      // For now, return bank transfer instructions\n      console.log('Equity Bank payment initiated:', {\n        reference,\n        amount: totalAmount,\n        account: config.account_number\n      });\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        provider_reference: reference,\n        instructions: `Please transfer ${totalAmount} RWF to Equity Bank account ${config.account_number} (${config.account_name}). Reference: ${transaction.our_reference}`,\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('Equity Bank payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate Equity Bank payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // TODO: Implement Equity Bank verification\n      // For now, return pending status\n      return {\n        success: false,\n        status: 'pending',\n        data: { message: 'Equity Bank verification not yet implemented' }\n      };\n\n    } catch (error: any) {\n      console.error('Equity Bank payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('equity_bank', 'payment_callback', payload);\n\n      // TODO: Implement Equity Bank webhook processing\n      console.log('Equity Bank webhook received:', payload);\n\n    } catch (error: any) {\n      console.error('Equity Bank webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      // TODO: Implement Equity Bank refund\n      console.log('Equity Bank refund requested:', request);\n\n      return {\n        success: false,\n        status: 'failed',\n        error: 'Equity Bank refunds not yet implemented'\n      };\n\n    } catch (error: any) {\n      console.error('Equity Bank refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process refund'\n      };\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAUO,MAAM,4BAA4B,oKAAoB;IACjD,gBAAgB,cAAc;IAChC,SAAkC,KAAK;IAE/C,MAAc,YAAuC;QACnD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAChB,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC;QAC5C;QACA,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA,MAAM,gBAAgB,OAA2B,EAAgC;QAC/E,IAAI;YACF,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;YAEnC,uBAAuB;YACvB,MAAM,IAAI,CAAC,kBAAkB,CAAC,eAAe,QAAQ,MAAM;YAE3D,iBAAiB;YACjB,MAAM,iBAAiB,IAAI,CAAC,aAAa,CACvC,QAAQ,MAAM,EACd,OAAO,uBAAuB,EAC9B,OAAO,SAAS;YAElB,MAAM,cAAc,QAAQ,MAAM,GAAG;YAErC,qBAAqB;YACrB,MAAM,YAAY,IAAI,CAAC,iBAAiB;YAExC,4BAA4B;YAC5B,MAAM,cAAc,MAAM,IAAI,CAAC,iBAAiB,CAAC,SAAS;YAE1D,8CAA8C;YAC9C,6CAA6C;YAC7C,QAAQ,GAAG,CAAC,kCAAkC;gBAC5C;gBACA,QAAQ;gBACR,SAAS,OAAO,cAAc;YAChC;YAEA,OAAO;gBACL,SAAS;gBACT,WAAW,YAAY,aAAa;gBACpC,oBAAoB;gBACpB,cAAc,CAAC,gBAAgB,EAAE,YAAY,4BAA4B,EAAE,OAAO,cAAc,CAAC,EAAE,EAAE,OAAO,YAAY,CAAC,cAAc,EAAE,YAAY,aAAa,EAAE;gBACpK,YAAY,YAAY,UAAU;YACpC;QAEF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,0CAA0C;YACxD,OAAO;gBACL,SAAS;gBACT,WAAW;gBACX,OAAO,MAAM,OAAO,IAAI;YAC1B;QACF;IACF;IAEA,MAAM,cAAc,SAAiB,EAAwC;QAC3E,IAAI;YACF,MAAM,cAAc,MAAM,IAAI,CAAC,cAAc,CAAC;YAE9C,IAAI,CAAC,aAAa;gBAChB,OAAO;oBACL,SAAS;oBACT,QAAQ;oBACR,OAAO;gBACT;YACF;YAEA,2CAA2C;YAC3C,iCAAiC;YACjC,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,MAAM;oBAAE,SAAS;gBAA+C;YAClE;QAEF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,4CAA4C;YAC1D,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,OAAO,MAAM,OAAO,IAAI;YAC1B;QACF;IACF;IAEA,MAAM,eAAe,OAAY,EAAiB;QAChD,IAAI;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,eAAe,oBAAoB;YAEzD,iDAAiD;YACjD,QAAQ,GAAG,CAAC,iCAAiC;QAE/C,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,0CAA0C;YACxD,MAAM;QACR;IACF;IAEA,MAAM,cAAc,OAAsB,EAA2B;QACnE,IAAI;YACF,qCAAqC;YACrC,QAAQ,GAAG,CAAC,iCAAiC;YAE7C,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,OAAO;YACT;QAEF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,8BAA8B;YAC5C,OAAO;gBACL,SAAS;gBACT,QAAQ;gBACR,OAAO,MAAM,OAAO,IAAI;YAC1B;QACF;IACF;AACF"}},
    {"offset": {"line": 669, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/payment/processors/crypto.ts"],"sourcesContent":["import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  CryptoConfig,\n  CryptoType\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\nexport class CryptoPaymentProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'crypto';\n  private config: CryptoConfig | null = null;\n\n  private async getConfig(): Promise<CryptoConfig> {\n    if (!this.config) {\n      this.config = await this.getPaymentConfig('crypto');\n    }\n    return this.config;\n  }\n\n  private async getExchangeRate(fromCurrency: string, toCurrency: string): Promise<number> {\n    const { data, error } = await supabaseAdmin\n      .from('exchange_rates')\n      .select('rate')\n      .eq('from_currency', fromCurrency)\n      .eq('to_currency', toCurrency)\n      .eq('source', 'coinbase')\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get exchange rate: ${error.message}`);\n    }\n\n    return data.rate;\n  }\n\n  private async convertToCrypto(amountRWF: number, cryptoType: CryptoType): Promise<number> {\n    const config = await this.getConfig();\n    \n    if (config.exchange_rate_provider === 'manual' && config.manual_exchange_rate) {\n      // Convert RWF to USD first, then to crypto\n      const usdAmount = amountRWF / config.manual_exchange_rate;\n      \n      switch (cryptoType) {\n        case 'bitcoin':\n          return usdAmount / 45000; // Approximate BTC price\n        case 'ethereum':\n          return usdAmount / 2500; // Approximate ETH price\n        case 'usdt':\n          return usdAmount; // USDT is pegged to USD\n        default:\n          throw new Error(`Unsupported crypto type: ${cryptoType}`);\n      }\n    } else {\n      // Get real exchange rates\n      const usdRate = await this.getExchangeRate('USD', 'RWF');\n      const usdAmount = amountRWF / usdRate;\n      \n      const cryptoRate = await this.getExchangeRate(cryptoType.toUpperCase(), 'USD');\n      return usdAmount / cryptoRate;\n    }\n  }\n\n  private getCryptoWalletAddress(cryptoType: CryptoType): string {\n    if (!this.config) {\n      throw new Error('Crypto configuration not loaded');\n    }\n\n    switch (cryptoType) {\n      case 'bitcoin':\n        return this.config.bitcoin.wallet_address;\n      case 'ethereum':\n        return this.config.ethereum.wallet_address;\n      case 'usdt':\n        return this.config.usdt.wallet_address;\n      default:\n        throw new Error(`Unsupported crypto type: ${cryptoType}`);\n    }\n  }\n\n  private generateQRCode(address: string, amount?: number): string {\n    // Simple QR code generation - in production, use a proper QR code library\n    const qrData = amount ? `${address}?amount=${amount}` : address;\n    const svg = `<svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"200\" height=\"200\" fill=\"white\"/>\n      <text x=\"100\" y=\"100\" text-anchor=\"middle\" font-size=\"12\">QR Code</text>\n      <text x=\"100\" y=\"120\" text-anchor=\"middle\" font-size=\"8\">${address.substring(0, 20)}...</text>\n    </svg>`;\n    return `data:image/svg+xml;base64,${Buffer.from(svg).toString('base64')}`;\n  }\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      const config = await this.getConfig();\n\n      if (!request.crypto_type) {\n        throw new Error('Crypto type is required for crypto payments');\n      }\n\n      if (!config[request.crypto_type].enabled) {\n        throw new Error(`${request.crypto_type} payments are not enabled`);\n      }\n\n      // Check payment limits\n      await this.checkPaymentLimits('crypto', request.amount);\n\n      // Convert RWF amount to crypto\n      const cryptoAmount = await this.convertToCrypto(request.amount, request.crypto_type);\n      const walletAddress = this.getCryptoWalletAddress(request.crypto_type);\n\n      // Generate reference\n      const reference = this.generateReference();\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request, reference);\n\n      // Generate QR code\n      const qrCodeUrl = this.generateQRCode(walletAddress, cryptoAmount);\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        wallet_address: walletAddress,\n        amount: cryptoAmount,\n        currency: request.crypto_type.toUpperCase(),\n        qr_code_url: qrCodeUrl,\n        exchange_rate: await this.getExchangeRate(request.crypto_type.toUpperCase(), 'RWF'),\n        instructions: `Please send ${cryptoAmount} ${request.crypto_type.toUpperCase()} to the provided address`,\n        expires_at: transaction.expires_at\n      };\n\n    } catch (error: any) {\n      console.error('Crypto payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to initiate crypto payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      // Check if expired\n      if (transaction.expires_at && new Date() > new Date(transaction.expires_at)) {\n        await this.updateTransactionStatus(reference, 'expired');\n        return {\n          success: false,\n          status: 'expired',\n          error: 'Transaction has expired'\n        };\n      }\n\n      // TODO: Implement blockchain monitoring\n      // For now, return pending status\n      return {\n        success: false,\n        status: 'pending',\n        data: { message: 'Crypto payment verification not yet implemented' }\n      };\n\n    } catch (error: any) {\n      console.error('Crypto payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify crypto payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    try {\n      await this.logWebhook('crypto', 'payment_callback', payload);\n\n      // TODO: Implement crypto webhook processing\n      console.log('Crypto webhook received:', payload);\n\n    } catch (error: any) {\n      console.error('Crypto webhook processing failed:', error);\n      throw error;\n    }\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      // TODO: Implement crypto refund\n      console.log('Crypto refund requested:', request);\n\n      return {\n        success: false,\n        status: 'failed',\n        error: 'Crypto refunds not yet implemented'\n      };\n\n    } catch (error: any) {\n      console.error('Crypto refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process crypto refund'\n      };\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 851, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/payment/processors/wallet.ts"],"sourcesContent":["import { BasePaymentProcessor } from '../base-processor';\nimport { \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse,\n  PaymentStatus\n} from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\nexport class WalletPaymentProcessor extends BasePaymentProcessor {\n  protected paymentMethod = 'wallet';\n\n  async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    try {\n      // Get user wallet\n      const wallet = await this.getUserWallet(request.user_id);\n\n      // Check if user has sufficient balance\n      if (wallet.balance < request.amount) {\n        return {\n          success: false,\n          reference: '',\n          error: `Insufficient wallet balance. Available: ${wallet.balance} RWF, Required: ${request.amount} RWF`\n        };\n      }\n\n      // Create transaction record\n      const transaction = await this.createTransaction(request);\n\n      // Process wallet payment immediately\n      await this.updateTransactionStatus(transaction.our_reference, 'completed');\n\n      return {\n        success: true,\n        reference: transaction.our_reference,\n        instructions: 'Payment completed successfully using wallet balance'\n      };\n\n    } catch (error: any) {\n      console.error('Wallet payment initiation failed:', error);\n      return {\n        success: false,\n        reference: '',\n        error: error.message || 'Failed to process wallet payment'\n      };\n    }\n  }\n\n  async verifyPayment(reference: string): Promise<PaymentVerificationResponse> {\n    try {\n      const transaction = await this.getTransaction(reference);\n\n      if (!transaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Transaction not found'\n        };\n      }\n\n      return {\n        success: true,\n        status: transaction.status,\n        data: transaction\n      };\n\n    } catch (error: any) {\n      console.error('Wallet payment verification failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to verify wallet payment'\n      };\n    }\n  }\n\n  async processWebhook(payload: any): Promise<void> {\n    // Wallet payments don't typically use webhooks since they're processed synchronously\n    console.log('Wallet webhook received (unexpected):', payload);\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    try {\n      const originalTransaction = await this.getTransaction(request.original_transaction_id);\n\n      if (!originalTransaction) {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Original transaction not found'\n        };\n      }\n\n      if (originalTransaction.status !== 'completed') {\n        return {\n          success: false,\n          status: 'failed',\n          error: 'Cannot refund a non-completed transaction'\n        };\n      }\n\n      // Create refund transaction\n      const refundTransaction = await this.createTransaction({\n        user_id: originalTransaction.user_id,\n        payment_method: 'wallet',\n        amount: request.amount || originalTransaction.amount,\n        currency: originalTransaction.currency,\n        transaction_type: 'refund',\n        description: `Refund for transaction ${originalTransaction.our_reference}: ${request.reason}`,\n        metadata: {\n          original_transaction_id: originalTransaction.id,\n          refund_reason: request.reason\n        }\n      });\n\n      // Process refund immediately\n      await this.updateTransactionStatus(refundTransaction.our_reference, 'completed');\n\n      // Create refund record\n      const { data: refundRecord } = await supabaseAdmin\n        .from('payment_refunds')\n        .insert({\n          original_transaction_id: request.original_transaction_id,\n          refund_transaction_id: refundTransaction.id,\n          amount: request.amount || originalTransaction.amount,\n          reason: request.reason,\n          status: 'completed',\n          processed_by: request.processed_by,\n          processed_at: new Date().toISOString()\n        })\n        .select()\n        .single();\n\n      return {\n        success: true,\n        refund_transaction_id: refundRecord.id,\n        status: 'completed'\n      };\n\n    } catch (error: any) {\n      console.error('Wallet refund failed:', error);\n      return {\n        success: false,\n        status: 'failed',\n        error: error.message || 'Failed to process wallet refund'\n      };\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 980, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/payment/factory.ts"],"sourcesContent":["import { \n  PaymentMethod, \n  IPaymentProcessor, \n  PaymentInitRequest, \n  PaymentInitResponse,\n  PaymentVerificationResponse,\n  RefundRequest,\n  RefundResponse\n} from '@/types/payment';\nimport { MTNMobileMoneyProcessor } from './processors/mtn-momo';\nimport { AirtelMoneyProcessor } from './processors/airtel-money';\nimport { EquityBankProcessor } from './processors/equity-bank';\nimport { CryptoPaymentProcessor } from './processors/crypto';\nimport { WalletPaymentProcessor } from './processors/wallet';\n\nexport class PaymentProcessorFactory {\n  private static processors: Map<PaymentMethod, IPaymentProcessor> = new Map();\n\n  static createProcessor(method: PaymentMethod): IPaymentProcessor {\n    // Check if we already have an instance\n    if (this.processors.has(method)) {\n      return this.processors.get(method)!;\n    }\n\n    let processor: IPaymentProcessor;\n\n    switch (method) {\n      case 'mtn_momo':\n        processor = new MTNMobileMoneyProcessor();\n        break;\n      case 'airtel_money':\n        processor = new AirtelMoneyProcessor();\n        break;\n      case 'equity_bank':\n        processor = new EquityBankProcessor();\n        break;\n      case 'crypto':\n        processor = new CryptoPaymentProcessor();\n        break;\n      case 'wallet':\n        processor = new WalletPaymentProcessor();\n        break;\n      default:\n        throw new Error(`Unsupported payment method: ${method}`);\n    }\n\n    // Cache the processor instance\n    this.processors.set(method, processor);\n    return processor;\n  }\n\n  static async initiatePayment(request: PaymentInitRequest): Promise<PaymentInitResponse> {\n    const processor = this.createProcessor(request.payment_method);\n    return await processor.initiatePayment(request);\n  }\n\n  static async verifyPayment(method: PaymentMethod, reference: string): Promise<PaymentVerificationResponse> {\n    const processor = this.createProcessor(method);\n    return await processor.verifyPayment(reference);\n  }\n\n  static async processWebhook(method: PaymentMethod, payload: any): Promise<void> {\n    const processor = this.createProcessor(method);\n    return await processor.processWebhook(payload);\n  }\n\n  static async refundPayment(method: PaymentMethod, request: RefundRequest): Promise<RefundResponse> {\n    const processor = this.createProcessor(method);\n    return await processor.refundPayment(request);\n  }\n\n  static getSupportedMethods(): PaymentMethod[] {\n    return ['mtn_momo', 'airtel_money', 'equity_bank', 'crypto', 'wallet'];\n  }\n\n  static async isMethodAvailable(method: PaymentMethod): Promise<boolean> {\n    try {\n      const processor = this.createProcessor(method);\n      // You could add a health check method to each processor\n      return true;\n    } catch (error) {\n      console.error(`Payment method ${method} not available:`, error);\n      return false;\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AASA;AACA;AACA;AACA;AACA;;;;;;AAEO,MAAM;IACX,OAAe,aAAoD,IAAI,MAAM;IAE7E,OAAO,gBAAgB,MAAqB,EAAqB;QAC/D,uCAAuC;QACvC,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS;YAC/B,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;QAC7B;QAEA,IAAI;QAEJ,OAAQ;YACN,KAAK;gBACH,YAAY,IAAI,+KAAuB;gBACvC;YACF,KAAK;gBACH,YAAY,IAAI,gLAAoB;gBACpC;YACF,KAAK;gBACH,YAAY,IAAI,8KAAmB;gBACnC;YACF,KAAK;gBACH,YAAY,IAAI,yKAAsB;gBACtC;YACF,KAAK;gBACH,YAAY,IAAI,yKAAsB;gBACtC;YACF;gBACE,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,QAAQ;QAC3D;QAEA,+BAA+B;QAC/B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ;QAC5B,OAAO;IACT;IAEA,aAAa,gBAAgB,OAA2B,EAAgC;QACtF,MAAM,YAAY,IAAI,CAAC,eAAe,CAAC,QAAQ,cAAc;QAC7D,OAAO,MAAM,UAAU,eAAe,CAAC;IACzC;IAEA,aAAa,cAAc,MAAqB,EAAE,SAAiB,EAAwC;QACzG,MAAM,YAAY,IAAI,CAAC,eAAe,CAAC;QACvC,OAAO,MAAM,UAAU,aAAa,CAAC;IACvC;IAEA,aAAa,eAAe,MAAqB,EAAE,OAAY,EAAiB;QAC9E,MAAM,YAAY,IAAI,CAAC,eAAe,CAAC;QACvC,OAAO,MAAM,UAAU,cAAc,CAAC;IACxC;IAEA,aAAa,cAAc,MAAqB,EAAE,OAAsB,EAA2B;QACjG,MAAM,YAAY,IAAI,CAAC,eAAe,CAAC;QACvC,OAAO,MAAM,UAAU,aAAa,CAAC;IACvC;IAEA,OAAO,sBAAuC;QAC5C,OAAO;YAAC;YAAY;YAAgB;YAAe;YAAU;SAAS;IACxE;IAEA,aAAa,kBAAkB,MAAqB,EAAoB;QACtE,IAAI;YACF,MAAM,YAAY,IAAI,CAAC,eAAe,CAAC;YACvC,wDAAwD;YACxD,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,eAAe,EAAE,OAAO,eAAe,CAAC,EAAE;YACzD,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 1065, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/app/api/payments/methods/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { PaymentProcessorFactory } from '@/lib/payment/factory';\nimport { PaymentMethodOption } from '@/types/payment';\nimport { supabaseAdmin } from '@/lib/supabase';\n\nexport async function GET() {\n  try {\n    // Get supported payment methods\n    const supportedMethods = PaymentProcessorFactory.getSupportedMethods();\n    \n    // Get payment configurations to check active status\n    const { data: configurations } = await supabaseAdmin\n      .from('payment_configurations')\n      .select('payment_method, is_active')\n      .in('payment_method', supportedMethods);\n\n    const paymentMethodOptions: PaymentMethodOption[] = [\n      {\n        id: 'wallet',\n        name: 'Wallet Balance',\n        displayName: 'Wallet Balance',\n        icon: '/icons/wallet.svg',\n        description: 'Pay using your wallet balance',\n        isActive: configurations?.find(c => c.payment_method === 'wallet')?.is_active ?? true,\n        requiresPhone: false,\n        requiresCryptoSelection: false\n      },\n      {\n        id: 'mtn_momo',\n        name: 'MTN Mobile Money',\n        displayName: 'MTN Mobile Money',\n        icon: '/icons/mtn-momo.png',\n        description: 'Pay with MTN Mobile Money',\n        isActive: configurations?.find(c => c.payment_method === 'mtn_momo')?.is_active ?? false,\n        requiresPhone: true,\n        requiresCryptoSelection: false\n      },\n      {\n        id: 'airtel_money',\n        name: 'Airtel Money',\n        displayName: 'Airtel Money',\n        icon: '/icons/airtel-money.png',\n        description: 'Pay with Airtel Money',\n        isActive: configurations?.find(c => c.payment_method === 'airtel_money')?.is_active ?? false,\n        requiresPhone: true,\n        requiresCryptoSelection: false\n      },\n      {\n        id: 'equity_bank',\n        name: 'Equity Bank',\n        displayName: 'Equity Bank',\n        icon: '/icons/equity-bank.png',\n        description: 'Pay with Equity Bank account',\n        isActive: configurations?.find(c => c.payment_method === 'equity_bank')?.is_active ?? false,\n        requiresPhone: false,\n        requiresCryptoSelection: false\n      },\n      {\n        id: 'crypto',\n        name: 'Cryptocurrency',\n        displayName: 'Cryptocurrency',\n        icon: '/icons/crypto.png',\n        description: 'Pay with Bitcoin, Ethereum, or USDT',\n        isActive: configurations?.find(c => c.payment_method === 'crypto')?.is_active ?? false,\n        requiresPhone: false,\n        requiresCryptoSelection: true,\n        supportedCryptos: ['bitcoin', 'ethereum', 'usdt']\n      }\n    ];\n\n    return NextResponse.json({\n      methods: paymentMethodOptions,\n      supported: supportedMethods\n    });\n  } catch (error: any) {\n    console.error('Error fetching payment methods:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAEA;;;;AAEO,eAAe;IACpB,IAAI;QACF,gCAAgC;QAChC,MAAM,mBAAmB,6JAAuB,CAAC,mBAAmB;QAEpE,oDAAoD;QACpD,MAAM,EAAE,MAAM,cAAc,EAAE,GAAG,MAAM,yIAAa,CACjD,IAAI,CAAC,0BACL,MAAM,CAAC,6BACP,EAAE,CAAC,kBAAkB;QAExB,MAAM,uBAA8C;YAClD;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,MAAM;gBACN,aAAa;gBACb,UAAU,gBAAgB,KAAK,CAAA,IAAK,EAAE,cAAc,KAAK,WAAW,aAAa;gBACjF,eAAe;gBACf,yBAAyB;YAC3B;YACA;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,MAAM;gBACN,aAAa;gBACb,UAAU,gBAAgB,KAAK,CAAA,IAAK,EAAE,cAAc,KAAK,aAAa,aAAa;gBACnF,eAAe;gBACf,yBAAyB;YAC3B;YACA;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,MAAM;gBACN,aAAa;gBACb,UAAU,gBAAgB,KAAK,CAAA,IAAK,EAAE,cAAc,KAAK,iBAAiB,aAAa;gBACvF,eAAe;gBACf,yBAAyB;YAC3B;YACA;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,MAAM;gBACN,aAAa;gBACb,UAAU,gBAAgB,KAAK,CAAA,IAAK,EAAE,cAAc,KAAK,gBAAgB,aAAa;gBACtF,eAAe;gBACf,yBAAyB;YAC3B;YACA;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,MAAM;gBACN,aAAa;gBACb,UAAU,gBAAgB,KAAK,CAAA,IAAK,EAAE,cAAc,KAAK,WAAW,aAAa;gBACjF,eAAe;gBACf,yBAAyB;gBACzB,kBAAkB;oBAAC;oBAAW;oBAAY;iBAAO;YACnD;SACD;QAED,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,WAAW;QACb;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}