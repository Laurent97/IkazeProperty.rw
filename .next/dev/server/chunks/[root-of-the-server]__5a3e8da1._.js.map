{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/cloudinary.ts"],"sourcesContent":["import { v2 as cloudinary } from 'cloudinary'\n\n// Configure Cloudinary\ncloudinary.config({\n  cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n  secure: true\n})\n\n// Upload function for server-side\nexport const uploadImage = async (\n  file: string,\n  options: {\n    folder?: string\n    transformation?: any\n    resource_type?: 'image' | 'video' | 'auto'\n  } = {}\n) => {\n  try {\n    const result = await cloudinary.uploader.upload(file, {\n      folder: options.folder || 'ikazeproperty',\n      resource_type: options.resource_type || 'auto',\n      transformation: options.transformation,\n      overwrite: false,\n      use_filename: true,\n      unique_filename: false,\n      filename_as_display_name: true\n    })\n\n    return {\n      url: result.secure_url,\n      public_id: result.public_id,\n      width: result.width,\n      height: result.height,\n      format: result.format,\n      size: result.bytes\n    }\n  } catch (error) {\n    console.error('Cloudinary upload error:', error)\n    throw new Error('Failed to upload image')\n  }\n}\n\n// Upload function for Buffer (server-side)\nexport const uploadBuffer = async (\n  buffer: Buffer,\n  filename: string,\n  options: {\n    folder?: string\n    transformation?: any\n    resource_type?: 'image' | 'video' | 'auto'\n  } = {}\n) => {\n  try {\n    return new Promise((resolve, reject) => {\n      const uploadStream = cloudinary.uploader.upload_stream(\n        {\n          folder: options.folder || 'ikazeproperty',\n          resource_type: options.resource_type || 'auto',\n          transformation: options.transformation,\n          overwrite: false,\n          use_filename: true,\n          unique_filename: false,\n          filename_as_display_name: true,\n          public_id: filename\n        },\n        (error, result) => {\n          if (error) {\n            reject(error)\n          } else if (result) {\n            resolve({\n              url: result.secure_url,\n              public_id: result.public_id,\n              width: result.width,\n              height: result.height,\n              format: result.format,\n              size: result.bytes\n            })\n          } else {\n            reject(new Error('Upload failed: No result returned'))\n          }\n        }\n      )\n      \n      uploadStream.end(buffer)\n    })\n  } catch (error) {\n    console.error('Cloudinary upload error:', error)\n    throw new Error('Failed to upload image')\n  }\n}\n\n// Delete function\nexport const deleteImage = async (public_id: string) => {\n  try {\n    const result = await cloudinary.uploader.destroy(public_id)\n    return result\n  } catch (error) {\n    console.error('Cloudinary delete error:', error)\n    throw new Error('Failed to delete image')\n  }\n}\n\n// Generate signed upload URL for client-side uploads\nexport const generateUploadSignature = (options: {\n  folder?: string\n  public_id?: string\n  timestamp?: number\n} = {}) => {\n  const timestamp = options.timestamp || Math.floor(Date.now() / 1000)\n  \n  const params: any = {\n    timestamp,\n    folder: options.folder || 'ikazeproperty',\n    overwrite: false,\n    use_filename: true,\n    unique_filename: false,\n    filename_as_display_name: true\n  }\n\n  if (options.public_id) {\n    params.public_id = options.public_id\n  }\n\n  const signature = cloudinary.utils.api_sign_request(params, process.env.CLOUDINARY_API_SECRET!)\n\n  return {\n    signature,\n    timestamp,\n    cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n    api_key: process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY,\n    folder: params.folder,\n    overwrite: params.overwrite,\n    use_filename: params.use_filename,\n    unique_filename: params.unique_filename,\n    filename_as_display_name: params.filename_as_display_name\n  }\n}\n\n// Get optimized image URL\nexport const getOptimizedImageUrl = (public_id: string, options: {\n  width?: number\n  height?: number\n  crop?: string\n  quality?: number\n  format?: string\n} = {}) => {\n  const transformation = {\n    width: options.width,\n    height: options.height,\n    crop: options.crop || 'fill',\n    quality: options.quality || 'auto',\n    format: options.format || 'auto',\n    ...options\n  }\n\n  return cloudinary.url(public_id, {\n    transformation,\n    secure: true\n  })\n}\n\n// Get thumbnail URL\nexport const getThumbnailUrl = (public_id: string, size: number = 200) => {\n  return getOptimizedImageUrl(public_id, {\n    width: size,\n    height: size,\n    crop: 'thumb',\n    quality: 80\n  })\n}\n\n// Get listing image URLs with different sizes\nexport const getListingImages = (public_id: string) => {\n  return {\n    thumbnail: getThumbnailUrl(public_id, 150),\n    small: getOptimizedImageUrl(public_id, { width: 300, height: 200, crop: 'fill' }),\n    medium: getOptimizedImageUrl(public_id, { width: 600, height: 400, crop: 'fill' }),\n    large: getOptimizedImageUrl(public_id, { width: 1200, height: 800, crop: 'fill' }),\n    original: cloudinary.url(public_id, { secure: true })\n  }\n}\n\nexport default cloudinary\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/watermark.ts"],"sourcesContent":["import sharp from 'sharp'\n\n// Add watermark to images\nexport const addImageWatermark = async (\n  imageBuffer: ArrayBuffer,\n  watermarkPath: string = '/images/ikazeproperty-logo.png'\n): Promise<Buffer> => {\n  try {\n    // For now, we'll use a simple text watermark since we can't easily access the logo file in server environment\n    // In production, you might want to store the watermark in Cloudinary and use their overlay features\n    \n    const watermarkSvg = `\n      <svg width=\"300\" height=\"60\" xmlns=\"http://www.w3.org/2000/svg\">\n        <defs>\n          <linearGradient id=\"grad1\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n            <stop offset=\"0%\" style=\"stop-color:#dc2626;stop-opacity:0.95\" />\n            <stop offset=\"100%\" style=\"stop-color:#991b1b;stop-opacity:0.95\" />\n          </linearGradient>\n          <filter id=\"shadow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n            <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"2\"/>\n            <feOffset dx=\"2\" dy=\"2\" result=\"offsetblur\"/>\n            <feComponentTransfer>\n              <feFuncA type=\"linear\" slope=\"0.3\"/>\n            </feComponentTransfer>\n            <feMerge> \n              <feMergeNode/>\n              <feMergeNode in=\"SourceGraphic\"/> \n            </feMerge>\n          </filter>\n        </defs>\n        <rect width=\"300\" height=\"60\" fill=\"url(#grad1)\" rx=\"8\" filter=\"url(#shadow)\" />\n        <text x=\"150\" y=\"35\" font-family=\"Arial, sans-serif\" font-size=\"18\" font-weight=\"bold\" fill=\"white\" text-anchor=\"middle\">\n          www.ikazeproperty.org\n        </text>\n      </svg>\n    `\n\n    const watermarkBuffer = Buffer.from(watermarkSvg)\n\n    const watermarkedImage = await sharp(Buffer.from(imageBuffer))\n      .composite([{\n        input: watermarkBuffer,\n        gravity: 'southeast',\n        blend: 'over'\n      }])\n      .png()\n      .toBuffer()\n\n    console.log('‚úÖ Watermark applied successfully to image')\n    return watermarkedImage\n  } catch (error) {\n    console.error('Error adding watermark:', error)\n    // Return original image if watermarking fails\n    return Buffer.from(imageBuffer)\n  }\n}\n\n// Cloudinary transformation for watermarking\nexport const getWatermarkTransformation = () => {\n  return {\n    transformation: [\n      {\n        overlay: {\n          url: 'https://res.cloudinary.com/demo/image/upload/w_200,h_60,c_fit/sample'\n        },\n        gravity: 'south_east',\n        x: 10,\n        y: 10,\n        opacity: 80\n      }\n    ]\n  }\n}\n\n// Alternative: Use Cloudinary's built-in text overlay\nexport const getTextWatermarkTransformation = () => {\n  return {\n    transformation: [\n      {\n        overlay: {\n          font_family: 'Arial',\n          font_size: 20,\n          font_weight: 'bold',\n          text: 'www.ikazeproperty.org',\n          color: '#ffffff'\n        },\n        gravity: 'south_east',\n        x: 15,\n        y: 15,\n        opacity: 95,\n        background: 'rgb(220,38,38)',\n        border: '3px_solid_rgb(153,27,27)',\n        radius: 8\n      }\n    ]\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAGO,MAAM,oBAAoB,OAC/B,aACA,gBAAwB,gCAAgC;IAExD,IAAI;QACF,8GAA8G;QAC9G,oGAAoG;QAEpG,MAAM,eAAe,CAAC;;;;;;;;;;;;;;;;;;;;;;;;IAwBtB,CAAC;QAED,MAAM,kBAAkB,OAAO,IAAI,CAAC;QAEpC,MAAM,mBAAmB,MAAM,IAAA,0JAAK,EAAC,OAAO,IAAI,CAAC,cAC9C,SAAS,CAAC;YAAC;gBACV,OAAO;gBACP,SAAS;gBACT,OAAO;YACT;SAAE,EACD,GAAG,GACH,QAAQ;QAEX,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,8CAA8C;QAC9C,OAAO,OAAO,IAAI,CAAC;IACrB;AACF;AAGO,MAAM,6BAA6B;IACxC,OAAO;QACL,gBAAgB;YACd;gBACE,SAAS;oBACP,KAAK;gBACP;gBACA,SAAS;gBACT,GAAG;gBACH,GAAG;gBACH,SAAS;YACX;SACD;IACH;AACF;AAGO,MAAM,iCAAiC;IAC5C,OAAO;QACL,gBAAgB;YACd;gBACE,SAAS;oBACP,aAAa;oBACb,WAAW;oBACX,aAAa;oBACb,MAAM;oBACN,OAAO;gBACT;gBACA,SAAS;gBACT,GAAG;gBACH,GAAG;gBACH,SAAS;gBACT,YAAY;gBACZ,QAAQ;gBACR,QAAQ;YACV;SACD;IACH;AACF"}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/app/api/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { uploadBuffer } from '@/lib/cloudinary'\nimport { addImageWatermark, getTextWatermarkTransformation } from '@/lib/watermark'\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('üöÄ Upload API called')\n    \n    // Check environment variables\n    console.log('üîë Environment variables check:', {\n      cloudName: !!process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n      apiKey: !!process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY,\n      apiSecret: !!process.env.CLOUDINARY_API_SECRET\n    })\n    \n    const formData = await request.formData()\n    const file = formData.get('file') as File\n    const folder = formData.get('folder') as string || 'ikazeproperty'\n    const resourceType = formData.get('resourceType') as string || 'auto'\n\n    console.log('üìÅ File details:', {\n      fileName: file?.name,\n      fileSize: file?.size,\n      fileType: file?.type,\n      folder,\n      resourceType\n    })\n\n    if (!file) {\n      console.error('‚ùå No file provided')\n      return NextResponse.json(\n        { error: 'No file provided' },\n        { status: 400 }\n      )\n    }\n\n    // Validate file\n    const bytes = await file.arrayBuffer()\n    let buffer = Buffer.from(bytes)\n\n    // Determine resource type based on file\n    const fileType = file.type.startsWith('video/') ? 'video' : 'image'\n    const detectedResourceType = formData.get('resourceType') as string || 'auto'\n    const finalResourceType = detectedResourceType === 'auto' ? fileType : detectedResourceType\n\n    // Watermarking disabled - only apply to new uploads when ready\n    // TODO: Re-enable watermarking when system is stable\n    if (false && fileType.startsWith('image/')) {\n      console.log('üñºÔ∏è Processing image file:', file.name, 'Type:', fileType)\n      try {\n        buffer = await addImageWatermark(bytes)\n        console.log('‚úÖ Watermark successfully added to image:', file.name)\n      } catch (error) {\n        console.warn('‚ö†Ô∏è Failed to add watermark, continuing with original image:', error)\n      }\n    } else if (false && fileType.startsWith('video/')) {\n      console.log('üé• Processing video file:', file.name, 'Type:', fileType)\n      console.log('üìù Will apply watermark via Cloudinary transformation')\n    }\n\n    // Check file size (limit to 100MB)\n    const maxSize = 100 * 1024 * 1024 // 100MB in bytes\n    if (buffer.length > maxSize) {\n      console.error('‚ùå File too large:', buffer.length, 'bytes')\n      return NextResponse.json(\n        { error: 'File size too large. Maximum size is 100MB.' },\n        { status: 400 }\n      )\n    }\n\n    console.log('üì§ Starting Cloudinary upload...')\n\n    // Upload to Cloudinary with appropriate settings\n    const uploadOptions: any = {\n      folder,\n      resource_type: finalResourceType as 'image' | 'video' | 'auto',\n      // Video-specific settings\n      ...(fileType.startsWith('video/') && {\n        chunk_size: '600k', // For better streaming\n        eager: 'streaming', // For video optimization\n        // Watermarking disabled for now\n        // ...getTextWatermarkTransformation() // Add watermark to videos\n      })\n    }\n\n    const result = await uploadBuffer(buffer, file.name, uploadOptions)\n\n    console.log('‚úÖ Cloudinary upload successful:', {\n      url: (result as any).secure_url || (result as any).url,\n      public_id: (result as any).public_id,\n      width: (result as any).width,\n      height: (result as any).height\n    })\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        url: (result as any).secure_url || (result as any).url,\n        public_id: (result as any).public_id,\n        size: file.size,\n        type: fileType,\n        duration: (result as any).duration || null, // Video duration if available\n        format: (result as any).format || null // Video format if available\n      }\n    })\n  } catch (error: any) {\n    console.error('‚ùå Upload error:', error)\n    return NextResponse.json({\n      success: false,\n      error: (error as any).message || 'Failed to upload file'\n    }, { status: 500 })\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const { public_id } = await request.json()\n\n    if (!public_id) {\n      return NextResponse.json(\n        { error: 'No public_id provided' },\n        { status: 400 }\n      )\n    }\n\n    const { deleteImage } = await import('@/lib/cloudinary')\n    const result = await deleteImage(public_id)\n\n    return NextResponse.json({\n      success: true,\n      data: result\n    })\n  } catch (error) {\n    console.error('Delete error:', error)\n    return NextResponse.json(\n      { error: 'Failed to delete file' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}