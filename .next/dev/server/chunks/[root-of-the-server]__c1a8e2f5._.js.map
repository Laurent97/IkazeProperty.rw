{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/lib/cloudinary.ts"],"sourcesContent":["import { v2 as cloudinary } from 'cloudinary'\n\n// Configure Cloudinary\ncloudinary.config({\n  cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n  secure: true\n})\n\n// Upload function for server-side\nexport const uploadImage = async (\n  file: string,\n  options: {\n    folder?: string\n    transformation?: any\n    resource_type?: 'image' | 'video' | 'auto'\n  } = {}\n) => {\n  try {\n    const result = await cloudinary.uploader.upload(file, {\n      folder: options.folder || 'ikazeproperty',\n      resource_type: options.resource_type || 'auto',\n      transformation: options.transformation,\n      overwrite: false,\n      use_filename: true,\n      unique_filename: false,\n      filename_as_display_name: true\n    })\n\n    return {\n      url: result.secure_url,\n      public_id: result.public_id,\n      width: result.width,\n      height: result.height,\n      format: result.format,\n      size: result.bytes\n    }\n  } catch (error) {\n    console.error('Cloudinary upload error:', error)\n    throw new Error('Failed to upload image')\n  }\n}\n\n// Upload function for Buffer (server-side)\nexport const uploadBuffer = async (\n  buffer: Buffer,\n  filename: string,\n  options: {\n    folder?: string\n    transformation?: any\n    resource_type?: 'image' | 'video' | 'auto'\n  } = {}\n) => {\n  try {\n    return new Promise((resolve, reject) => {\n      const uploadStream = cloudinary.uploader.upload_stream(\n        {\n          folder: options.folder || 'ikazeproperty',\n          resource_type: options.resource_type || 'auto',\n          transformation: options.transformation,\n          overwrite: false,\n          use_filename: true,\n          unique_filename: false,\n          filename_as_display_name: true,\n          public_id: filename\n        },\n        (error, result) => {\n          if (error) {\n            reject(error)\n          } else if (result) {\n            resolve({\n              url: result.secure_url,\n              public_id: result.public_id,\n              width: result.width,\n              height: result.height,\n              format: result.format,\n              size: result.bytes\n            })\n          } else {\n            reject(new Error('Upload failed: No result returned'))\n          }\n        }\n      )\n      \n      uploadStream.end(buffer)\n    })\n  } catch (error) {\n    console.error('Cloudinary upload error:', error)\n    throw new Error('Failed to upload image')\n  }\n}\n\n// Delete function\nexport const deleteImage = async (public_id: string) => {\n  try {\n    const result = await cloudinary.uploader.destroy(public_id)\n    return result\n  } catch (error) {\n    console.error('Cloudinary delete error:', error)\n    throw new Error('Failed to delete image')\n  }\n}\n\n// Generate signed upload URL for client-side uploads\nexport const generateUploadSignature = (options: {\n  folder?: string\n  public_id?: string\n  timestamp?: number\n} = {}) => {\n  const timestamp = options.timestamp || Math.floor(Date.now() / 1000)\n  \n  const params: any = {\n    timestamp,\n    folder: options.folder || 'ikazeproperty',\n    overwrite: false,\n    use_filename: true,\n    unique_filename: false,\n    filename_as_display_name: true\n  }\n\n  if (options.public_id) {\n    params.public_id = options.public_id\n  }\n\n  const signature = cloudinary.utils.api_sign_request(params, process.env.CLOUDINARY_API_SECRET!)\n\n  return {\n    signature,\n    timestamp,\n    cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n    api_key: process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY,\n    folder: params.folder,\n    overwrite: params.overwrite,\n    use_filename: params.use_filename,\n    unique_filename: params.unique_filename,\n    filename_as_display_name: params.filename_as_display_name\n  }\n}\n\n// Get optimized image URL\nexport const getOptimizedImageUrl = (public_id: string, options: {\n  width?: number\n  height?: number\n  crop?: string\n  quality?: number\n  format?: string\n} = {}) => {\n  const transformation = {\n    width: options.width,\n    height: options.height,\n    crop: options.crop || 'fill',\n    quality: options.quality || 'auto',\n    format: options.format || 'auto',\n    ...options\n  }\n\n  return cloudinary.url(public_id, {\n    transformation,\n    secure: true\n  })\n}\n\n// Get thumbnail URL\nexport const getThumbnailUrl = (public_id: string, size: number = 200) => {\n  return getOptimizedImageUrl(public_id, {\n    width: size,\n    height: size,\n    crop: 'thumb',\n    quality: 80\n  })\n}\n\n// Get listing image URLs with different sizes\nexport const getListingImages = (public_id: string) => {\n  return {\n    thumbnail: getThumbnailUrl(public_id, 150),\n    small: getOptimizedImageUrl(public_id, { width: 300, height: 200, crop: 'fill' }),\n    medium: getOptimizedImageUrl(public_id, { width: 600, height: 400, crop: 'fill' }),\n    large: getOptimizedImageUrl(public_id, { width: 1200, height: 800, crop: 'fill' }),\n    original: cloudinary.url(public_id, { secure: true })\n  }\n}\n\nexport default cloudinary\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":["file:///D:/Apps/IkazeProperty.rw/src/app/api/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { uploadBuffer } from '@/lib/cloudinary'\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('üöÄ Upload API called')\n    \n    // Check environment variables\n    console.log('üîë Environment variables check:', {\n      cloudName: !!process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n      apiKey: !!process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY,\n      apiSecret: !!process.env.CLOUDINARY_API_SECRET\n    })\n    \n    const formData = await request.formData()\n    const file = formData.get('file') as File\n    const folder = formData.get('folder') as string || 'ikazeproperty'\n    const resourceType = formData.get('resourceType') as string || 'auto'\n\n    console.log('üìÅ File details:', {\n      fileName: file?.name,\n      fileSize: file?.size,\n      fileType: file?.type,\n      folder,\n      resourceType\n    })\n\n    if (!file) {\n      console.error('‚ùå No file provided')\n      return NextResponse.json(\n        { error: 'No file provided' },\n        { status: 400 }\n      )\n    }\n\n    // Validate file\n    const bytes = await file.arrayBuffer()\n    const buffer = Buffer.from(bytes)\n\n    // Check file size (limit to 100MB)\n    const maxSize = 100 * 1024 * 1024 // 100MB in bytes\n    if (buffer.length > maxSize) {\n      console.error('‚ùå File too large:', buffer.length, 'bytes')\n      return NextResponse.json(\n        { error: 'File size too large. Maximum size is 100MB.' },\n        { status: 400 }\n      )\n    }\n\n    // Determine resource type based on file\n    const fileType = file.type.startsWith('video/') ? 'video' : 'image'\n    const detectedResourceType = formData.get('resourceType') as string || 'auto'\n    const finalResourceType = detectedResourceType === 'auto' ? fileType : detectedResourceType\n\n    console.log('üì§ Starting Cloudinary upload...')\n\n    // Upload to Cloudinary with appropriate settings\n    const result = await uploadBuffer(buffer, file.name, {\n      folder,\n      resource_type: finalResourceType as 'image' | 'video' | 'auto',\n      // Video-specific settings\n      ...(fileType.startsWith('video/') && {\n        chunk_size: '600k', // For better streaming\n        eager: 'streaming' // For video optimization\n      })\n    })\n\n    console.log('‚úÖ Cloudinary upload successful:', {\n      url: (result as any).secure_url || (result as any).url,\n      public_id: (result as any).public_id,\n      width: (result as any).width,\n      height: (result as any).height\n    })\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        url: (result as any).secure_url || (result as any).url,\n        public_id: (result as any).public_id,\n        size: file.size,\n        type: fileType,\n        duration: (result as any).duration || null, // Video duration if available\n        format: (result as any).format || null // Video format if available\n      }\n    })\n  } catch (error: any) {\n    console.error('‚ùå Upload error:', error)\n    return NextResponse.json({\n      success: false,\n      error: (error as any).message || 'Failed to upload file'\n    }, { status: 500 })\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const { public_id } = await request.json()\n\n    if (!public_id) {\n      return NextResponse.json(\n        { error: 'No public_id provided' },\n        { status: 400 }\n      )\n    }\n\n    const { deleteImage } = await import('@/lib/cloudinary')\n    const result = await deleteImage(public_id)\n\n    return NextResponse.json({\n      success: true,\n      data: result\n    })\n  } catch (error) {\n    console.error('Delete error:', error)\n    return NextResponse.json(\n      { error: 'Failed to delete file' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}